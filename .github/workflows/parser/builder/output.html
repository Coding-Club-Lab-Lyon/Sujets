<html><head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="src/report.css">
    <link rel="stylesheet" href="src/code.css">
    <style>
        @page {
            margin-top: 2.5cm;

            @top-left {
                background: #4c5270;
                color: white;
                content: counter(page);
                height: 1cm;
                text-align: center;
                width: 1cm;
                margin-bottom: 0.6cm;
            }

            @top-center {
                background: #4c5270;
                content: '';
                display: block;
                height: .05cm;
                opacity: .5;
                width: 100%;
                margin-bottom: 0.6cm;
            }

            @top-right {
                content: string(heading);
                font-size: 9pt;
                height: 1cm;
                vertical-align: middle;
                width: 100%;
                margin-bottom: 0.6cm;
            }
        }
    </style>
<style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuTitle {background-color: #CCCCCC; margin: -5px 0 0 0; text-align: center; font-style: italic; font-size: 80%; color: #444444; padding: 2px 0; overflow: hidden}
.MathJax_MenuArrow {position: absolute; right: .5em; color: #666666}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_Menu_Close {position: absolute; width: 31px; height: 31px; top: -15px; left: -15px}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style></head>

<body><div id="MathJax_Message" style="display: none;"></div>
    <h2>I. Introduction</h2>
<p>En 1989, Viki est une jeune hongroise passionnée de Rubik’s cube. Depuis quelques années, elle se lasse des tournois, survolant l’adversité à chaque fois. Elle a alors l’idée de créer un programme qui résout les fameux cubes contre lesquels elle pourrait s’entraîner. En effet, Viki a découvert la programmation quelques semaines auparavant et elle aura besoin de ton aide pour réussir son projet et faire fonctionner son code.</p>
<p><img alt="" src="https://www.variantes.com/1399-thickbox_default/rubik-s-cube-3-x-3-x-3.jpg"></p>
<h2>II. Le programme</h2>
<p>Ce sujet est à réaliser en <strong>ruby</strong>, un langage orienté objet open-source. Avec lui, on va pouvoir comprendre comment créer une <strong>classe</strong> et lui ajouter des <strong>méthodes</strong>.</p>
<p><em>L'architecture des fichiers est déjà donnée.</em></p>
<p>On lancera notre programme grâce à la commande :</p>
<div class="codehilite"><pre><span></span><code>ruby algo.rb
</code></pre></div>

<blockquote class="warning">
<p> <i class="fa"></i> Le programme fonctionne grâce à la librairie Colorize, si elle n'est pas installée sur l'ordinateur, vous pouvez le faire avec la commande <code>gem install colorize</code></p>
</blockquote>
<p><img alt="" src="assets/ruby.png"></p>
<h2>III. Récupère le cube !</h2>
<p>Commence par regarder les fichiers « .txt » dans le dossier <strong>"cubes"</strong>. C’est comme cela que seront stockées les faces des Rubik’s Cubes. </p>
<p>Pour récupérer le Rubik's Cube, tu vas devoir créer une Classe qui va l'accueillir. Ta classe contiendra ton cube et des fonctions qui te permettront d'en faire tourner les faces.</p>
<p>Dans le fichier <code>rubic.rb</code> déclare une classe comme ceci :</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Rubic</span> <span class="o">&lt;</span> <span class="no">Cube</span>
<span class="k">end</span>
</code></pre></div>

<blockquote class="info">
<p> <i class="fa"></i> Le <code>&lt; Cube</code> permet de récupérer des fonctions préparées à l'avance et de les ajouter à ta classe.</p>
</blockquote>
<p>Tu peux maintenant charger un premier Rubik's Cube dans <code>algo.rb</code> en écrivant :</p>
<div class="codehilite"><pre><span></span><code><span class="n">ru</span> <span class="o">=</span> <span class="no">Rubic</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"chemin/vers/rubikscube.txt"</span><span class="p">)</span>
</code></pre></div>

<p><pagebreak></pagebreak></p>
<p><strong>Ton cube est stocké dans un liste,</strong> ses faces sont numérotées comme ceci :</p>
<p><img alt="" src="assets/patron.png"></p>
<p>Le Rubik's Cube sera stocké comme une liste de faces.</p>
<p>Une face est stockée comme ceci :</p>
<div class="codehilite"><pre><span></span><code><span class="o">[</span>
    <span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span><span class="p">,</span>
    <span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span><span class="p">,</span>
    <span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span>
<span class="o">]</span>
</code></pre></div>

<blockquote class="info">
<p> <i class="fa"></i> <code>ru.get_rubic</code> permet d'accéder à une copie de cette liste pour vérifier la position des cases par exemple.</p>
</blockquote>
<h2>IV. Crée le mouvement U et Ui.</h2>
<h3>1. Crée le mouvement U</h3>
<p>Le mouvement U consiste à déplacer la ligne supérieure du cube dans le sens horaire.</p>
<p>La fonction <code>rotate_inface</code>, déjà existante, pourra t'être utile, elle permet de tourner une face dans le sens horaire mais ne tourne pas ses arêtes...</p>
<p>Pour tourner les arêtes :</p>
<p>La <strong>ligne 0</strong> de la <strong>face 0</strong> prendra la valeur de la <strong>ligne 0</strong> de la <strong>face 1</strong>.</p>
<p>La <strong>ligne 0</strong> de la <strong>face 1</strong> prendra la valeur de la <strong>ligne 0</strong> de la <strong>face 2</strong> etc.</p>
<p>Ajoute une méthode "u" à ta classe comme ceci :</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Rubic</span> <span class="o">&lt;</span> <span class="no">Cube</span>
    <span class="k">def</span> <span class="nf">u</span>
        <span class="c1"># Code</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>

<blockquote class="warning">
<p> <i class="fa"></i> <strong>Attention</strong> à ne pas dupliquer des lignes de ton Rubik's Cube !</p>
</blockquote>
<h3>2. Crée le mouvement Ui</h3>
<p>Maintenant que tu as réussi la rotation U, tu peux faire le mouvement inverse, le mouvement Ui.</p>
<p>Tu as deux manières de le faire, soit tu fais l’inverse de ce que tu as fait précédemment, soit tu fais 3 fois la rotation U.</p>
<blockquote>
<p>Et oui, faire quatre fois la même rotation c’est comme ne rien faire !</p>
</blockquote>
<p><img alt="" src="assets/u.png"></p>
<h2>V. Résous la face blanche du Rubik’s Cube.</h2>
<blockquote class="info">
<p> <i class="fa"></i> Les autres méthodes de rotation du Rubik's Cube sont déjà implémentées.</p>
</blockquote>
<p><strong>À partir d’ici, on va travailler dans le fichier <code>algo.rb</code>.</strong></p>
<h3>1. Monter la face blanche</h3>
<p>Pour résoudre un Rubik's Cube, on doit le prendre en main correctement. Pour ce faire, on va devoir le tourner dans tous les sens jusqu'à ce que la face blanche soit en haut.</p>
<p>Crée une fonction <code>def monter_face_blanche(ru)</code> qui ramènera la face blanche du cube au-dessus, peu importe la configuration de départ.</p>
<p>Pour ceci, tu peux utiliser les méthodes <code>ru.transform_left</code>, <code>ru.transform_right</code>, <code>ru.transform_up</code> et <code>ru.transform_down</code> qui permettent de tourner le cube dans toutes les directions.</p>
<p>Avec cette première fonction, on peut commencer la résolution de notre cube.</p>
<p>On va l'appeler puis afficher notre cube après transformation dans la fonction "algo".</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">algo</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span>
    <span class="n">monter_face_blanche</span> <span class="n">ru</span>
    <span class="nb">print</span> <span class="s2">" ----  Monter Face Blanche ----</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">ru</span>
<span class="k">end</span>
</code></pre></div>

<p><pagebreak></pagebreak></p>
<h3>2. Croix blanche</h3>
<p>La première étape de la résolution d'un Rubik's Cube, est de former une croix sur la face blanche. La croix est bonne à condition que les arêtes soient de la couleur de leur face.</p>
<p>Exemple :</p>
<p><img alt="" src="assets/ar.png"></p>
<p>Si les 4 arêtes ne sont pas bien placées à l’origine, au moins 2 d’entre elles le seront forcément.</p>
<p>Une fois qu’on les a trouvées il faut appliquer l’une des 2 formules possibles, en fonction du cas de figure :</p>
<p>La fonction <code>def aretes_adj(ru)</code> sera appelée si les 2 arêtes bien placées se situent sur des faces adjacentes. Voici la formule à appliquer :</p>
<p><img alt="" src="assets/arr_adj.png"></p>
<p>La fonction <code>def aretes_opp(ru)</code> quant à elle sera appelée si les 2 arêtes sont situées sur des faces opposées. Applique la suite ci-dessous pour résoudre la face.</p>
<p><img alt="" src="assets/arr_opp.png"></p>
<p><strong>À toi de créer ces fonctions !</strong></p>
<p>Elles vont être utilisées dans la fonction <strong>"croix_blanche"</strong> qui se trouve dans le fichier <code>resol.rb</code>.</p>
<p><pagebreak></pagebreak></p>
<p>On peut à nouveau appeler cette fonction dans notre fonction algo, comme pour <strong>"monter_face_blanche"</strong>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">algo</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span>
    <span class="n">monter_face_blanche</span> <span class="n">ru</span>
    <span class="nb">print</span> <span class="s2">" ----  Monter Face Blanche ----</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">ru</span>
    <span class="n">croix_blanche</span> <span class="n">ru</span>
    <span class="nb">print</span> <span class="s2">" ----  Croix Blanche ----</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">ru</span>
<span class="k">end</span>
</code></pre></div>

<blockquote class="warning">
<p> <i class="fa"></i> <strong>Attention</strong> Si tu n’obtiens pas la croix blanche, reprend l’étape précédente ou demande l’aide d’un Cobra.</p>
</blockquote>
<h3>3. Coins blancs</h3>
<p>Maintenant on va placer correctement les coins blancs.</p>
<p>La formule pour placer un coin est la suivante :</p>
<p><img alt="" src="assets/coins.png"></p>
<p>Crée la fonction <code>def serie_coins(ru)</code> qui exécute cette série.</p>
<p>Cette fonction sera appelée par la fonction <strong>"coins_blancs"</strong> qu'on exécutera de la même manière que <strong>"croix_blanche"</strong> dans notre fonction <strong>"algo"</strong>.</p>
<h2>VI. La deuxième couronne.</h2>
<p>Maintenant que tu as réussi à résoudre une face, il faut résoudre les autres !</p>
<p>L’étape suivante consiste à constituer la « deuxième couronne » : la ligne du milieu du cube.</p>
<p>Il faut, une nouvelle fois, appliquer une suite de mouvements dans la fonction <code>def deuxieme_couronne(ru)</code>, mais attention, il y a deux cas différents.</p>
<p><img alt="" src="assets/courone.png"></p>
<p>La <strong>situation 1</strong> peut se traduire par :</p>
<ul>
<li>Le milieu de la première ligne de la face 1 est de la même couleur que le milieu de la face 1<br><strong>et</strong><br>Le milieu de la dernière ligne de la face 4 est de la même couleur que le milieu de la face 2</li>
</ul>
<p><strong>ou</strong></p>
<ul>
<li>La case de droite de la ligne centrale de la face 1 est de la même couleur que le milieu de la face 2<br><strong>et</strong><br>La case de gauche de la ligne centrale de la face 2 est de la même couleur que le milieu de la face 1</li>
</ul>
<p><strong>Dans ce cas-là,</strong> on réalise la série suivante :</p>
<p><img alt="" src="assets/case1.png"></p>
<p>La <strong>situation 2</strong> peut se traduire par :</p>
<ul>
<li>Le milieu de la première ligne de la face 1 est de la même couleur que le milieu de la face 1<br><strong>et</strong><br>Le milieu de la dernière ligne de la face 4 est de la même couleur que le milieu de la face 0</li>
</ul>
<p><strong>Dans ce cas-là,</strong> on réalise la série suivante :</p>
<p><img alt="" src="assets/case2.png"></p>
<p><pagebreak></pagebreak></p>
<p>On va créer cette fonction ensemble en complétant le code ci-dessous:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">deuxieme_couronne</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ru</span><span class="o">.</span><span class="n">get_rubic</span>

    <span class="k">until</span> <span class="n">is_2couronne_correct?</span> <span class="n">r</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">situation1</span><span class="p">)</span>
                <span class="c1"># actions situation 1</span>
            <span class="k">elsif</span> <span class="p">(</span><span class="n">situation2</span><span class="p">)</span>
                <span class="c1"># actions situation 2</span>
        <span class="k">end</span>
        <span class="n">ru</span><span class="o">.</span><span class="n">ui</span>
    <span class="k">end</span>
    <span class="n">ru</span><span class="o">.</span><span class="n">transform_right</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>

<p>Il ne reste plus qu'à créer les conditions et effectuer les bonnes actions !</p>
<blockquote class="warning">
<p> <i class="fa"></i> Cette partie est un peu complexe, n'hésite pas à solliciter l'aide d'un Cobra.</p>
</blockquote>
<p>On va maintenant retourner horizontalement notre Rubik's Cube pour que la face jaune se retrouve en haut et appeler notre fonction <strong>"deuxieme_couronne"</strong> dans la fonction <strong>"algo"</strong> :</p>
<div class="codehilite"><pre><span></span><code><span class="n">ru</span><span class="o">.</span><span class="n">transform_down</span> 
<span class="n">ru</span><span class="o">.</span><span class="n">transform_down</span>
<span class="n">deuxieme_couronne</span> <span class="n">ru</span>
<span class="nb">print</span> <span class="s2">" ----  2e Couronne ----</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">ru</span>
</code></pre></div>

<h2>VII. La croix jaune.</h2>
<p>L’étape suivante consiste à reformer la croix jaune.</p>
<p>La fonction "croix_jaune" du fichier <code>resol.rb</code> va avoir besoin d'une série d'actions.</p>
<p>On va l'écrire dans la fonction <code>def serie_croix_jaune(ru)</code></p>
<p>Cette série d'actions consiste à :</p>
<ul>
<li>Abaisser la face de droite</li>
<li>Tourner la face du haut dans le sens anti-horaire</li>
<li>Tourner la face avant dans le sens anti-horaire</li>
<li>Faire les mêmes mouvements dans l'autre direction et dans l'ordre 2-3-1</li>
</ul>
<p>En appelant <strong>"croix_jaune"</strong>, on place correctement la croix mais pas les arêtes, il vous faudra aussi appeler <strong>"croix_sup"</strong> pour que tout soit bon.</p>
<p><img alt="" src="assets/yellow_cross.png"></p>
<h2>VIII. Les coins jaunes.</h2>
<p>Dans cette étape, il va falloir placer correctement les coins jaunes sur notre Rubik’s Cube.</p>
<p>On va compléter la fonction ci-dessous :</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">coins_jaunes</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ru</span><span class="o">.</span><span class="n">get_rubic</span>

    <span class="c1"># Verification 1</span>

    <span class="k">if</span> <span class="n">coins_bien_places</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># Code 1</span>
    <span class="k">else</span>
        <span class="c1"># Code 2</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>

<p>On va commencer par créer une fonction <code>def placement_formule(ru)</code> qui va exécuter une série d'actions qui nous sera utile pour la suite de notre fonction <strong>"coins_jaunes"</strong>.</p>
<p>La série d'actions est juste ici :</p>
<div class="codehilite"><pre><span></span><code><span class="sx"><i class="fa"></i> 3 (<i class="fa"></i> 23)   x u xl ol x ul xl o</span><span class="w"></span>
</code></pre></div>

<p><em>À vous de la déchiffrer...</em></p>
<p><pagebreak></pagebreak></p>
<h3>Revenons à notre fonction "coins_jaunes"</h3>
<p>Dans un premier temps, il va falloir tourner le cube jusqu'à avoir le coin d'en haut à droite bien placé.</p>
<p>Si après 4 tours, on ne trouve toujours pas de coin bien placé, on applique notre fonction <strong>"placement_formule"</strong> et on rappelle notre fonction <strong>"coins_jaunes"</strong>.</p>
<blockquote class="info">
<p> <i class="fa"></i> La fonction <strong>"coins_bien_places"</strong> indique si TOUS les coins sont bien placés (Ça peut sembler fou mais je vous jure que c'est vrai).<br><br>À l'inverse, la fonction <strong>"premier_coin_bien_place"</strong> va vérifier seulement le coin en haut à droite de la face.</p>
</blockquote>
<p><strong>Si on a trouvé un coin bien placé :</strong></p>
<ul>
<li>Appeler <strong>"placement_formule"</strong></li>
<li>S'il reste des coins mal placés<ul>
<li>Rappeler <strong>"placement_formule"</strong></li>
</ul>
</li>
</ul>
<blockquote class="success">
<p> <i class="fa"></i> Pensez à appeler votre nouvelle fonction dans <strong>"algo"</strong>.</p>
</blockquote>
<h2>IX. Tourner les coins jaunes.</h2>
<p>Vous avez bien travaillé, cette fonction-là elle est <strong>cadeau</strong> ! </p>
<p>Vous allez juste devoir retrouver son nom dans le fichier <code>resol.rb</code> et l'appeler à la suite des autres !</p>
<p><img alt="" src="assets/gift.png"></p>
<h2>X. Conclusion.</h2>
<p>Bravo, grâce à toi Viki à trouver un adversaire à sa hauteur. </p>
<p>Mais elle ne va sans doute pas mettre longtemps à surpasser ce programme. </p>
<p>Tu peux donc aider Viki à améliorer l’algorithme pour qu’elle continue à progresser !</p>
<p><img alt="" src="assets/sol.png"></p>

    <script type="text/x-mathjax-config;executed=true">
        MathJax.Hub.Config({
      messageStyle: "none",
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        fonts: ["TeX"],
        scale: 85,
      }
    });
  </script>
    <script src="src/MathJax.js"></script>


</body></html>